## DRAM
![[Pasted image 20240926132920.png]]
![[Pasted image 20240926133302.png]]
메모리의 구조를 나타내는 메모리 맵입니다.
SRAM인 캐시메모리가아닌 주기억 장치인 DRAM을 시각화 한것입니다.

메모리맵에서 Segment란 메모리의 구역을 나누어 각 영역을 다르게 관리하는 방식을 의미합니다.

- BSS(Block Started by Symbol)
  초기값 없는 전역변수나 정적 변수(static variable)가 저장됩니다. 프로그램은 시작될때 0으로 자동 초기화합니다.
- DATA
  초기값이 설정된 전역변수나 정적변수가 저정됩니다. 프로그램이 시작되기 전에 메모리에 로드되며, main함수 시작전에 초기값이 복사됩니다.
- CONST
  특정 상수변수, 초기값을 저장하는 공간입니다.
- RODATA
  변경 불가능한 데이터를 저장하는 공간, 문자열 리터럴, 상수 값(상수배열)등이 포함됩니다.

**DATA, CONST** 의 관계
- DATA 영역은 프로그램 시작전 메모리에 로드될 정보를 CONST에서 가져옵니다. 이는 메모리관리의 효율성을 위합입니다. 초기값을 CONST에 **변경 불가능한 값**으로 안전하게 보존하여 프로그램의 초기 상태를 보존합니다.

**CONST, RODATA** 의 관계
둘다 변경되지않는 데이터를 저정하는 영역에서 겹치는 느낌이 많이듭니다. 실제로 많은 시스템에서 RODATA와 CONST는 동일한 메모리 영역을 가르키기도합니다. 

- TEXT
  프로그램의 기계어코드가 저장되는 영역입니다. 실행 가능한 코드들이 저장되며 프로그램이 실행할때 CPU는 이 영역의 명령어를 읽고 실행합니다.

- HEAP
  동적 메모리할당이 이루어지는 영역입니다. 사용자에 의해 선언되고 관리되는 영역입니다.


- STACK
  함수 호출시 생성되는 지역변수와 매개변수들이 저장되는 영역이며, 이름에서 알 수 있듯이 실제 스택구조를 가지고 LIFO방식으로 작동합니다. 재귀함수호출이 가능한 이유는 이러한 스택프레임을 사용하기 때문입니다. 대표적으로 COBOL언어는 STACK 영역이 없기에 재귀호출이 가능하지 않습니다.

### 저장방식
![[Pasted image 20240926142013.png]]
- 리틀 엔디안 : 높은 번지 주소부터 저장하는 방식 -> 수치 계산이 편리하다는 장점이 있습니다. 123 + 456을 저장한다 하였을때 가장 작은 값인 일의 자리수 3, 6부터 계산하듯이 가장 작은 값부터 저장되어있는 데이터의 시작점에서 수치를 계산 나가거나 자리올림할 수 있습니다.
- 빅 엔디안 : 낮은 번지 주소부터 저장하는 방식 -> 일상의 숫자 체계와 동일한 순서여서 디버깅시 편하다는 장점이 있습니다.
```C
#include <stdio.h>

void check_endianess() {
    unsigned int x = 0x12345678; // 임의의 정수
    unsigned char *ptr = (unsigned char*)&x; // 정수를 바이트 단위로 접근하기 위한 포인터

    if (*ptr == 0x78) { //시작주소의 값을보고 저장방식을 판단합니다.
        printf("리틀 엔디안(Little Endian)입니다.\n");
    } else {
        printf("빅 엔디안(Big Endian)입니다.\n");
    }
}

int main() {
    check_endianess();
    return 0;
}
```


## SRAM 
CPU는 프로그램 실행과정에서 메모리에 자주 접근하는데 이때 CPU의 메모리 접근속도와 연산속도의 차이가 발생합니다. 일반적으로 메모리 접근속도가 더 느리기때문에 병목현상이 일어나는데 이것을 해결하기위해 메모리의 일부 데이터를 미리 가져와 저장하는 SRAM 기반 메모리, 캐시메모리가 있습니다.

CPU와 가까운 순서로 L1, L2, L3 캐시로 구분합니다. 일반적으로 L1, L2는 CPU 내부에 L3캐시는 CPU 외부에 존재합니다.

- 캐시메모리가 저장하는것
	캐시메모리는 **CPU가 사용할 법한 것** 들을 저장합니다. 캐시메모리에 저장된 데이터를 사용하다면 이를 캐시히트라고하고 그렇지않다면 캐시미스라고 부릅니다.
	캐시가 히트되는 비율을 캐시 적중률이라하며 이것을 높이기위해 다음과 같은 이론들이 제시됩니다.
	- 참조 지역성의 원리 - 시간 지역성
	  CPU는 최근 접근했던 메모리공간에 다시 접근하려는 경향이 있다는것이 시간 지역성입니다. 이것을 잘보여주는 대표적인 사례는 **변수**가 있습니다.
	- 참조 지역성의 원리 - 공간 지역성
	  CPU는 접근한 메모리 공간의 근처에 접근하려는 경향이 있다는것이 공간 지역성입니다. 이것을 잘보여주는 대표적인 사례는 **배열**이 있습니다.

- 캐시 메모리의 쓰기 정책과 일관성
	캐시메모리는 메모리의 정보를 가져와 보관합니다. CPU가 데이터를 가져올때 캐시히트를하여 캐시메모리를 가져오고 이 정보를 수정한다면 캐시메모리와 메모리의 값이 서로 달라지는 경우가 생길 수 있습니다. 이를 방지하기 위한 방법에는 크게 2가지가 있습니다.
	- 즉시쓰기(write-through)
		캐시메모리와 메모리에 동시에 쓰는 방법으로 일관성을 유지합니다. 하지만 데이터를 쓸 때마다 메모리를 참조해야 하므로 캐시 메모리를 둔 효율이 떨어집니다.
	- 지연쓰기(write-back)
		캐시 메모리에만 값을 써둔후 추후 수정된 데이터를 메모리에 한번에 반영하는 방법입니다. 메모리 접근 횟수는 줄일수있지만 일관성이 깨질 수 있는 위험이 있습니다.


